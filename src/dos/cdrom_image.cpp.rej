--- src/dos/cdrom_image.cpp
+++ src/dos/cdrom_image.cpp
@@ -369,39 +515,126 @@
 	mediaPresent = true;
 	mediaChanged = false;
 	trayOpen = false;
+
+	#ifdef DEBUG
+	LOG_MSG("%s CDROM: GetMediaTrayStatus present=%d, changed=%d, open=%d", get_time(), mediaPresent, mediaChanged, trayOpen);
+	#endif
+
 	return true;
 }
 
-bool CDROM_Interface_Image::PlayAudioSector(unsigned long start,unsigned long len)
+bool CDROM_Interface_Image::PlayAudioSector(unsigned long start, unsigned long len)
 {
-	// We might want to do some more checks. E.g valid start and length
-	SDL_mutexP(player.mutex);
-	player.cd = this;
-	player.currFrame = start;
-	player.targetFrame = start + len;
-	int track = GetTrack(start) - 1;
-	if(track >= 0 && tracks[track].attr == 0x40) {
+	bool is_playable(false);
+	const int track = GetTrack(start) - 1;
+
+	// The CDROM Red Book standard allows up to 99 tracks, which includes the data track
+	if ( track < 0 || track > 99 )
+		LOG(LOG_MISC, LOG_WARN)("Game tried to load track #%d, which is invalid", track);
+
+	// Attempting to play zero sectors is a no-op
+	else if (len == 0)
+		LOG(LOG_MISC, LOG_WARN)("Game tried to play zero sectors, skipping");
+
+	// The maximum storage achieved on a CDROM was ~900MB or just under 100 minutes
+	// with overburning, so use this threshold to sanity-check the start sector.
+	else if (start > 450000)
+		LOG(LOG_MISC, LOG_WARN)("Game tried to read sector %lu, which is beyond the 100-minute maximum of a CDROM", start);
+
+	// We can't play audio from a data track (as it would result in garbage/static)
+	else if(track >= 0 && tracks[track].attr == 0x40)
 		LOG(LOG_MISC,LOG_WARN)("Game tries to play the data track. Not doing this");
-		player.isPlaying = false;
-		//Unclear wether return false should be here. 
-		//specs say that this function returns at once and games should check the status wether the audio is actually playing
-		//Real drives either fail or succeed as well
-	} else player.isPlaying = true;
-	player.isPaused = false;
-	SDL_mutexV(player.mutex);
-	return true;
+
+	// Checks passed, setup the audio stream
+	else {
+		TrackFile* trackFile = tracks[track].file;
+
+		// Convert the playback start sector to a time offset (milliseconds) relative to the track
+		const Bit32u offset = tracks[track].skip + (start - tracks[track].start) * tracks[track].sectorSize;
+		is_playable = trackFile->seek(offset);
+
+		// only initialize the player elements if our track is playable
+		if (is_playable) {
+			const Bit8u channels = trackFile->getChannels();
+			const Bit32u rate = trackFile->getRate();
+
+			player.cd = this;
+			player.trackFile = trackFile;
+			player.startFrame = start;
+			player.currFrame = start;
+			player.numFrames = len;
+			player.bufferPos = 0;
+			player.bufferConsumed = 0;
+			player.isPlaying = true;
+			player.isPaused = false;
+
+			if ( (!IS_BIGENDIAN && trackFile->getEndian() == AUDIO_S16SYS) ||
+			     ( IS_BIGENDIAN && trackFile->getEndian() != AUDIO_S16SYS) )
+				player.addSamples = channels ==  2  ? &MixerChannel::AddSamples_s16 \
+				                                    : &MixerChannel::AddSamples_m16;
+			else
+				player.addSamples = channels ==  2  ? &MixerChannel::AddSamples_s16_nonnative \
+				                                    : &MixerChannel::AddSamples_m16_nonnative;
+
+			const float bytesPerMs = rate * channels * 2 / 1000.0;
+			player.playbackTotal = lround(len * tracks[track].sectorSize * bytesPerMs / 176.4);
+			player.playbackRemaining = player.playbackTotal;
+
+			#ifdef DEBUG
+			LOG_MSG(
+			   "%s CDROM: Playing track %d at %.1f KHz %d-channel at start sector %lu (%.1f minute-mark), seek %u (skip=%d,dstart=%d,secsize=%d), for %lu sectors (%.1f seconds)",
+			   get_time(),
+			   track,
+			   rate/1000.0,
+			   channels,
+			   start,
+			   offset * (1/10584000.0),
+			   offset,
+			   tracks[track].skip,
+			   tracks[track].start,
+			   tracks[track].sectorSize,
+			   len,
+			   player.playbackRemaining / (1000 * bytesPerMs)
+			);
+			#endif
+
+			// start the channel!
+			player.channel->SetFreq(rate);
+			player.channel->Enable(true);
+		}
+	}
+	if (!is_playable) StopAudio();
+	return is_playable;
 }
 
 bool CDROM_Interface_Image::PauseAudio(bool resume)
 {
-	player.isPaused = !resume;
+	// Only switch states if needed
+	if (player.isPaused == resume) {
+		player.channel->Enable(resume);
+		player.isPaused = !resume;
+	}
+
+	#ifdef DEBUG
+	LOG_MSG("%s CDROM: PauseAudio, state=%s", get_time(), resume ? "resumed" : "paused");
+	#endif
+
 	return true;
 }
 
 bool CDROM_Interface_Image::StopAudio(void)
 {
-	player.isPlaying = false;
-	player.isPaused = false;
+	// Only switch states if needed
+	if (player.isPlaying) {
+		player.channel->Enable(false);
+		player.isPlaying = false;
+		player.isPaused = false;
+	}
+
+	#ifdef DEBUG
+	LOG_MSG("%s CDROM: StopAudio", get_time());
+	#endif
+
 	return true;
 }
 
